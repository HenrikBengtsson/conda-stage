#! /usr/bin/env bash
### conda-stage: Stage Conda Environment on Local Disk
### 
### Usage:
###  conda-stage [options]
### 
### Options:  
###  --help              Display the full help page with examples
###  --version           Output version of this software
###  --debug             Output detailed debug information
###  --verbose           Output informative message
###  --quiet             Silence all output
###  --force             Force an action, e.g. repacking environment
###  --full              Output more information
###  --source            Generate conda-stage() shell function
###  --readonly          Make the staged environment readonly
###  --pack              Package up a conda environment
###  --unstage           Unstage and remove staged environment
###  --path=<path>       Directory where conda environment should be
###                      staged (Default: `mktemp -d`)
### ---
###
### Example:
###  conda-stage --help
###  conda-stage --version
###  conda-stage --version --full
###
###  ## Bash only
###  eval "$(conda-stage --source)"
###  conda activate myenv
###  conda-stage
###
###  ## Other shells
###  conda activate myenv
###  stage_path=$(mktemp -d)
###  conda-stage --path="${stage_path}"
###  source "${stage_path}/bin/activate"
###
###  conda-stage --pack --force
###
### Version: 0.2.0-9009
### Copyright: Henrik Bengtsson (2022)
### License: ISC

this="${BASH_SOURCE%/}"
[[ -L "${this}" ]] && this=$(readlink "${this}")

## Import bash utility functions
incl="$(dirname "${this}")/incl"

# shellcheck source=incl/asserts.sh
source "${incl}/asserts.sh"
# shellcheck source=incl/cli.sh
source "${incl}/cli.sh"
# shellcheck source=incl/conditions.sh
source "${incl}/conditions.sh"
# shellcheck source=incl/files.sh
source "${incl}/files.sh"
# shellcheck source=incl/output.sh
source "${incl}/output.sh"
# shellcheck source=incl/ports.sh
source "${incl}/ports.sh"
# shellcheck source=incl/system.sh
source "${incl}/system.sh"


# =========================================================================
# Utility functions
# =========================================================================

function assert_conda {
    if ! command -v conda &> /dev/null; then
        merror "Executable 'conda' not found"
    fi
}

function conda_version {
    local res
    res=$(conda --version 2> /dev/null)
    # shellcheck disable=SC2181
    [[ $? -eq 0 ]] || return 1
    sed -E 's/^conda[[:space:]]+//' <<< "${res}"
}    

function conda_pack_version {
    local res
    res=$(conda-pack --version 2> /dev/null)
    # shellcheck disable=SC2181
    [[ $? -eq 0 ]] || return 1
    sed -E 's/^conda-pack[[:space:]]+//' <<< "${res}"
}    


function conda_pack_cache_file {
    local path
    
    mdebug "- CONDA_PREFIX=${CONDA_PREFIX}"
    assert_dir_exists "${CONDA_PREFIX}"
    path=$(dirname "${CONDA_PREFIX}")
    mdebug "- Stage cache path: ${path}"
    assert_dir_exists "${path}"

    echo "${path}/${CONDA_DEFAULT_ENV}.tar.gz"
}

function conda_pack {
    local opts
    local file
    local tmp_tarball
    
    if [[ -z ${CONDA_DEFAULT_ENV} ]]; then
        merror "No active conda environment, e.g. 'conda activate <name>'"
    fi
    mdebug "- Current conda environment: ${CONDA_DEFAULT_ENV}"

    ## Assert that environment is not already staged
    if [[ -f "${CONDA_PREFIX}/.conda-stage" ]]; then
         merror "Conda environment is already staged and active: ${CONDA_PREFIX}"
    fi
    
    assert_conda
    mdebug "- Using conda $(conda_version)"

    ## Install conda-pack?
    if ! command -v conda-pack &> /dev/null; then
        minfo "Installing conda-pack ..."
        opts=("--yes")
        if ! $verbose; then
            opts+=("--quiet")
        fi
        mdebug "Additional 'conda install' options: ${opts[*]}"
        ## WORKAROUND: 'conda install' outputs some "progress" to stdout, not
        ## stderr (https://github.com/HenrikBengtsson/conda-stage/issues/15)
        ## Because of this, we direct stdout to stderr here.
        ## WORKAROUND 2: conda install --quiet does _not_ silence its stdout
        ## output, which means we have to redirect everything to /dev/null
        ## if verbose=false.
        if $verbose; then
            1>&2 conda install "${opts[@]}" --channel=conda-forge conda-pack
        else
            conda install "${opts[@]}" --channel=conda-forge conda-pack &> /dev/null
        fi
    fi
    mdebug "- Using conda-pack $(conda_pack_version)"

    file=$(conda_pack_cache_file)

    ## Skip existing conda-pack file?
    if $force && [[ -f "${file}" ]]; then
        mdebug "Removing existing conda-pack file: ${file}"
        rm -f "${file}"
    fi

    ## Create conda-pack file?
    if [[ ! -f "${file}" ]]; then
        minfo "Packaging conda environment ..."
        opts=()
        if ! $verbose; then
            opts+=("--quiet")
        fi
        mdebug "Additional 'conda-pack' options: ${opts[*]}"
        ## ROBUSTNESS: Have 'conda-pack' produce the tarball atomically by
        ## writing to a temporary file which is renamed on success.  Since
        ## 'conda-pack' looks at the filename extension, we can just append
        ## '.tmp' at the end, because that'll be an error. Instead, we
        ## prepend '.tmp.' to the basename.
        tmp_tarball=$(dirname "${file}")/.tmp.$(basename "${file}")
        
        ## WORKAROUND: conda-pack outputs "progress" to stdout, not stderr
        ## (https://github.com/conda/conda-pack/issues/217). Because of this,
        ## we direct stdout to stderr here.
        1>&2 conda-pack "${opts[@]}" --output="${tmp_tarball}"
        mv "${tmp_tarball}" "${file}"
    fi
    mdebug "- Packaged conda environment: $(file_info "${file}")"
    assert_file_exists "${file}"
    
    echo "${file}"
}

function file_info {
    assert_file_exists "${1:?}"
    stat -t --printf "%n (%s bytes; %y)" "$1"
}

# =========================================================================
# MAIN
# =========================================================================
action=stage
dryrun=false
force=false
verbose=true
args=()
full=false
path=${CONDA_STAGE_PATH}
readonly=false

# Parse command-line options
while [[ $# -gt 0 ]]; do
    mdebug "Next CLI argument: $1"
    ## Options (--flags):
    if [[ "$1" == "--help" ]]; then
        action=help
    elif [[ "$1" == "--version" ]]; then
        action=version
    elif [[ "$1" == "--debug" ]]; then
        debug=true
    elif [[ "$1" == "--dryrun" ]]; then
        dryrun=true
    elif [[ "$1" == "--quiet" ]]; then
        verbose=false
    elif [[ "$1" == "--force" ]]; then
        force=true
    elif [[ "$1" == "--full" ]]; then
        full=true
    elif [[ "$1" == "--source" ]]; then
        action=source
    elif [[ "$1" == "--readonly" ]]; then
        readonly=true
    elif [[ "$1" == "--unstage" ]]; then
        action=unstage
    elif [[ "$1" == "--pack" ]]; then
        action=pack
    ## Options (--key=value):
    elif [[ "$1" =~ ^--.*=.*$ ]]; then
        key=${1//--}
        key=${key//=*}
        value=${1//--[[:alpha:]]*=}
        mdebug "Key-value option '$1' parsed to key='${key}', value='${value}'"
        if [[ -z ${value} ]]; then
            merror "Option '--${key}' must not be empty"
        fi
        if [[ "${key}" == "path" ]]; then
            path=${value}
        else
            merror "Unknown option: $1"
        fi
    else
        ## Additional options to be appended (rarely needed)
        args+=("$1")
    fi
    shift
done


## Log actiokn to file?
if [[ -n ${CONDA_STAGE_LOGFILE} ]]; then
    echo "action: $action" >> "${CONDA_STAGE_LOGFILE}"
fi

## --help should always be available prior to any validation errors
if [[ -z $action ]]; then
    help
    _exit 0
elif [[ $action == "help" ]]; then
    help full
    _exit 0
elif [[ $action == "version" ]]; then
    if $full; then
        echo "conda-stage: $(version)"
        echo "conda: $(conda_version || echo "<please install Miniconda or Anaconda>")"
    else
        version
    fi
    _exit 0
fi


# -------------------------------------------------------------------------
# Validate options
# -------------------------------------------------------------------------


# -------------------------------------------------------------------------
# Initiate
# -------------------------------------------------------------------------
mdebug "action: ${action}"
mdebug "debug: ${debug}"
mdebug "verbose: ${verbose}"
mdebug "dryrun: ${dryrun}"
mdebug "force: ${force}"
mdebug "args: [n=${#args[@]}] ${args[*]}"


if [[ "${action}" == "source" ]]; then
    file="$(dirname "${this}")/conda-stage.sh"
    assert_file_exists "$file"
    cat "${file}"
    exit 0
fi

if [[ "${action}" == "pack" ]]; then
    minfo "Package current conda environment (${CONDA_PREFIX}) to cache ..."
    mdebug "- Using conda-stage $(version)"

    ## Already done?
    file=$(conda_pack_cache_file)
    if ! $force && [[ -f "${file}" ]]; then
        merror "Package tarball already exists. Use --force to recreate: ${file}"
    fi

    conda_pack_cache_file=$(conda_pack)
    minfo "Created conda-pack tarball: ${conda_pack_cache_file}"
    exit 0
fi

if [[ "${action}" == "unstage" ]]; then
    minfo "Unstaging and reverting to original conda environment  ..."
    ## Assert that we are working with a staged environment
    if [[ -z ${CONDA_PREFIX} ]]; then
        merror "Does not look like a staged environment: CONDA_PREFIX is not set"
    fi
    assert_dir_exists "${CONDA_PREFIX}"

    if [[ ! -f "${CONDA_PREFIX}/.conda-stage" ]]; then
        merror "Does not look like a staged environment: No '${CONDA_PREFIX}/.conda-stage' file found"
    fi

    mdebug "- Staged conda environment: ${CONDA_PREFIX}"

    original=$(cat "${CONDA_PREFIX}/.conda-stage")
    minfo "Original conda environment: ${original}"

    minfo "Removing all staged files: ${CONDA_PREFIX}"
    rm -rf "${CONDA_PREFIX}"

    cmd="conda activate \"${original}\""
    mdebug "Command to activate original conda environment: $cmd"
    echo "$cmd"

    minfo "Activating original conda environment: ${original}"
    exit 0
fi

if [[ "${action}" == "stage" ]]; then
    minfo "Staging current conda environment (${CONDA_PREFIX}) to local disk ..."
    mdebug "- Using conda-stage $(version)"

    conda_env_name=${CONDA_DEFAULT_ENV}    
    conda_pack_cache_file=$(conda_pack)

    if [[ -z $path ]]; then
        path=$(mktemp --directory --tmpdir="${TMPDIR}" conda-stage-XXXX)
        path=${path}/${conda_env_name}
    fi
    if [[ -d "${path}" ]]; then
        merror "Stage folder must not exist: ${path}"
    fi
    mdebug "- Stage path: ${path}"

    minfo "Extracting $(file_info "${conda_pack_cache_file}") to ${path}"
    ## Create stage folder so it's blocked while we extract
    make_dir "${path}"
    ## Extract atomically, i.e. write to temporary folder and rename
    make_dir "${path}.tmp"
    tar -xf "${conda_pack_cache_file}" -C "${path}.tmp"
    chmod -R u+w "${path}.tmp"
    remove_dir "${path}"
    mv "${path}.tmp" "${path}"

    ## Record original conda environment
    echo "${CONDA_PREFIX}" > "${path}/.conda-stage"

    minfo "Unpacking"
    # shellcheck source=/dev/null
    source "${path}/bin/activate"
    conda-unpack
    ## Set the conda prompt used by PS1 prompt (optional)
    conda config --env --set env_prompt "(${conda_env_name}*) "
    
    if $readonly; then
        mdebug "- Make read-only"
        chmod -R ugo-w "${path}"
    fi

    cmd="conda activate \"${path}\""
    mdebug "Command to activate staged conda environment: $cmd"
    echo "$cmd"
    
    minfo "Activating staged conda environment: ${path}"
    exit 0
fi
