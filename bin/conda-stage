#! /usr/bin/env bash
### conda-stage: Stage Conda Environment on Local Disk
### 
### Usage:
###  conda-stage [options]
### 
### Options:  
###  --help              Display the full help page with examples
###  --version           Output version of this software
###  --debug             Output detailed debug information
###  --verbose           Output informative message
###  --quiet             Silence all output
###  --force             Force an action, e.g. repacking environment
###  --full              Output more information
###  --source            Generate conda-stage() shell function
###  --read-only         Make the staged environment read-only
###  --pack              Package up a conda environment
###  --unstage           Unstage and remove staged environment
###  --auto-stage=<cmd>  'enable' or 'disable' automatic staging when
###                      activating the original conda environment
###  --path=<path>       Directory where conda environment should be
###                      staged (Default: `mktemp -d`)
### ---
###
### Example:
###  conda-stage --help
###  conda-stage --version
###  conda-stage --version --full
###
###  ## Bash only
###  eval "$(conda-stage --source)"
###  conda activate myenv
###  conda-stage
###
###  ## Other shells
###  conda activate myenv
###  stage_path=$(mktemp -d)
###  conda-stage --path="${stage_path}"
###  source "${stage_path}/bin/activate"
###
###  conda-stage --pack --force
###  conda-stage --auto-stage=enable --read-only
###  conda-stage --auto-stage=disable
###
### Version: 0.4.0
### Copyright: Henrik Bengtsson (2022)
### License: ISC

this="${BASH_SOURCE%/}"
[[ -L "${this}" ]] && this=$(readlink "${this}")

## Import bash utility functions
incl="$(dirname "${this}")/incl"

# shellcheck source=incl/asserts.sh
source "${incl}/asserts.sh"
# shellcheck source=incl/cli.sh
source "${incl}/cli.sh"
# shellcheck source=incl/conditions.sh
source "${incl}/conditions.sh"
# shellcheck source=incl/files.sh
source "${incl}/files.sh"
# shellcheck source=incl/output.sh
source "${incl}/output.sh"
# shellcheck source=incl/ports.sh
source "${incl}/ports.sh"
# shellcheck source=incl/system.sh
source "${incl}/system.sh"


# =========================================================================
# Utility functions
# =========================================================================

function assert_conda {
    if ! command -v conda &> /dev/null; then
        merror "Executable 'conda' not found"
    fi
}

function conda_version {
    local res
    res=$(conda --version 2> /dev/null)
    # shellcheck disable=SC2181
    [[ $? -eq 0 ]] || return 1
    sed -E 's/^conda[[:space:]]+//' <<< "${res}"
}    

function conda_pack_version {
    local res
    res=$(conda-pack --version 2> /dev/null)
    # shellcheck disable=SC2181
    [[ $? -eq 0 ]] || return 1
    sed -E 's/^conda-pack[[:space:]]+//' <<< "${res}"
}    


function conda_pack_cache_file {
    local path
    
    mdebug "- CONDA_PREFIX=${CONDA_PREFIX}"
    assert_dir_exists "${CONDA_PREFIX}"
    path=$(dirname "${CONDA_PREFIX}")
    mdebug "- Stage cache path: ${path}"
    assert_dir_exists "${path}"

    echo "${path}/${CONDA_DEFAULT_ENV}.tar.gz"
}

function assert_active_conda_environment {
    if [[ -z ${CONDA_DEFAULT_ENV} ]]; then
        merror "No active conda environment, e.g. 'conda activate <name>'"
    fi
}

function conda_pack {
    local opts
    local file
    local tmp_tarball
    local t0
    local dt
    
    assert_active_conda_environment
    mdebug "- Current conda environment: ${CONDA_DEFAULT_ENV}"

    ## Assert that environment is not already staged
    if [[ -f "${CONDA_PREFIX}/.conda-stage" ]]; then
         merror "Conda environment is already staged and active: ${CONDA_PREFIX}"
    fi
    
    assert_conda
    mdebug "- Using conda $(conda_version)"

    ## Install conda-pack?
    if ! command -v conda-pack &> /dev/null; then
        t0=$SECONDS
        minfo "Installing conda-pack ..."
        opts=("--yes")
        if ! $verbose; then
            opts+=("--quiet")
        fi
        mdebug "Additional 'conda install' options: ${opts[*]}"
        ## WORKAROUND: 'conda install' outputs some "progress" to stdout, not
        ## stderr (https://github.com/HenrikBengtsson/conda-stage/issues/15)
        ## Because of this, we direct stdout to stderr here.
        ## WORKAROUND 2: conda install --quiet does _not_ silence its stdout
        ## output, which means we have to redirect everything to /dev/null
        ## if verbose=false.
        if $verbose; then
            1>&2 conda install "${opts[@]}" --channel=conda-forge conda-pack
        else
            conda install "${opts[@]}" --channel=conda-forge conda-pack &> /dev/null
        fi
        dt=$((SECONDS - t0))
        minfo "Total installation time: ${dt} seconds"

        ## Assert installation was successful
        if ! command -v conda-pack &> /dev/null; then
            merror "Failed to install 'conda-pack'"
        fi
    fi
    mdebug "- Using conda-pack $(conda_pack_version)"

    file=$(conda_pack_cache_file)

    ## Skip existing conda-pack file?
    if $force && [[ -f "${file}" ]]; then
        mdebug "Removing existing conda-pack file: ${file}"
        rm -f "${file}"
    fi

    ## Create conda-pack file?
    if [[ ! -f "${file}" ]]; then
        t0=$SECONDS
        minfo "Packaging conda environment ..."
        opts=()
        if ! $verbose; then
            opts+=("--quiet")
        fi
        mdebug "Additional 'conda-pack' options: ${opts[*]}"
        ## ROBUSTNESS: Have 'conda-pack' produce the tarball atomically by
        ## writing to a temporary file which is renamed on success.  Since
        ## 'conda-pack' looks at the filename extension, we can just append
        ## '.tmp' at the end, because that'll be an error. Instead, we
        ## prepend '.tmp.' to the basename.
        tmp_tarball=$(dirname "${file}")/.tmp.$(basename "${file}")
        
        ## WORKAROUND: conda-pack outputs "progress" to stdout, not stderr
        ## (https://github.com/conda/conda-pack/issues/217). Because of this,
        ## we direct stdout to stderr here.
        1>&2 conda-pack "${opts[@]}" --output="${tmp_tarball}"
        mv "${tmp_tarball}" "${file}"

        dt=$((SECONDS - t0))
        minfo "Total 'conda-pack' time: ${dt} seconds"
    fi
    mdebug "- Packaged conda environment: $(file_info "${file}")"
    assert_file_exists "${file}"
    
    echo "${file}"
}

function file_info {
    assert_file_exists "${1:?}"
    stat -t --printf "%n (%s bytes; %y)" "$1"
}

# =========================================================================
# MAIN
# =========================================================================
action=stage
debug=${CONDA_STAGE_DEBUG:-false}
dryrun=false
force=false
verbose=true
args=()
full=false
path=${CONDA_STAGE_PATH}
readonly=false
autostage=false

# Parse command-line options
while [[ $# -gt 0 ]]; do
    mdebug "Next CLI argument: $1"
    ## Options (--flags):
    if [[ "$1" == "--help" ]]; then
        action=help
    elif [[ "$1" == "--version" ]]; then
        action=version
    elif [[ "$1" == "--debug" ]]; then
        debug=true
    elif [[ "$1" == "--dryrun" ]]; then
        dryrun=true
    elif [[ "$1" == "--quiet" ]]; then
        verbose=false
    elif [[ "$1" == "--force" ]]; then
        force=true
    elif [[ "$1" == "--full" ]]; then
        full=true
    elif [[ "$1" == "--source" ]]; then
        action=source
    elif [[ "$1" == "--read-only" ]]; then
        readonly=true
    elif [[ "$1" == "--unstage" ]]; then
        action=unstage
    elif [[ "$1" == "--pack" ]]; then
        action=pack
    ## Options (--key=value):
    elif [[ "$1" =~ ^--.*=.*$ ]]; then
        key=${1//--}
        key=${key//=*}
        value=${1//--[[:alpha:]]*=}
        mdebug "Key-value option '$1' parsed to key='${key}', value='${value}'"
        if [[ -z ${value} ]]; then
            merror "Option '--${key}' must not be empty"
        fi
        if [[ "${key}" == "path" ]]; then
            path=${value}
        elif [[ "${key}" == "auto-stage" ]]; then
            action=autostage
            if [[ ${value} == "enable" ]]; then
                autostage=true
            elif [[ ${value} == "disable" ]]; then
                autostage=false
            else
                merror "Unknown value of option '--auto-stage=${value}'"
            fi
        else
            merror "Unknown option: $1"
        fi
    else
        ## Additional options to be appended (rarely needed)
        args+=("$1")
    fi
    shift
done


## Log actiokn to file?
if [[ -n ${CONDA_STAGE_LOGFILE} ]]; then
    echo "action: $action" >> "${CONDA_STAGE_LOGFILE}"
fi

## --help should always be available prior to any validation errors
if [[ -z $action ]]; then
    help
    _exit 0
elif [[ $action == "help" ]]; then
    help full
    _exit 0
elif [[ $action == "version" ]]; then
    if $full; then
        echo "conda-stage: $(version)"
        echo "conda: $(conda_version || echo "<please install Miniconda or Anaconda>")"
    else
        version
    fi
    _exit 0
fi


# -------------------------------------------------------------------------
# Validate options
# -------------------------------------------------------------------------


# -------------------------------------------------------------------------
# Initiate
# -------------------------------------------------------------------------
mdebug "action: ${action}"
mdebug "debug: ${debug}"
mdebug "verbose: ${verbose}"
mdebug "dryrun: ${dryrun}"
mdebug "force: ${force}"
mdebug "args: [n=${#args[@]}] ${args[*]}"

CONDA_STAGE_DEBUG=${debug}

if [[ "${action}" == "source" ]]; then
    file="$(dirname "${this}")/conda-stage.sh"
    assert_file_exists "$file"
    cat "${file}"
    exit 0
fi

if [[ "${action}" == "pack" ]]; then
    minfo "Package current conda environment (${CONDA_PREFIX}) to cache ..."
    mdebug "- Using conda-stage $(version)"

    ## Already done?
    file=$(conda_pack_cache_file)
    if ! $force && [[ -f "${file}" ]]; then
        merror "Package tarball already exists. Use --force to recreate: ${file}"
    fi

    conda_pack_cache_file=$(conda_pack)
    exit_code=$?
    if [[ $exit_code -ne 0 ]]; then
        exit "$exit_code"
    fi
    
    minfo "Created conda-pack tarball: ${conda_pack_cache_file}"
    exit 0
fi

if [[ "${action}" == "autostage" ]]; then
    minfo "Configuring automatic staging of original conda environment  ..."
    assert_active_conda_environment

    if [[ -f "${CONDA_PREFIX}/.conda-stage" ]]; then
        merror "Cannot configure auto-staging of a staged environment. Call 'conda-stage --unstage' first"
    fi
    
    mdebug "- autostage=${autostage}"

    path=${CONDA_PREFIX}/etc/conda/activate.d
    mdebug "- path=${path}"
    file=${path}/zzz.conda-stage-auto.sh
    mdebug "- file=${file}"

    if $autostage; then
        mdebug "- readonly=${readonly}"
        opts=()
        if $readonly; then
            opts+=("--read-only")
        fi    
        cat > "${file}.tmp" << EOF
if [[ \${CONDA_STAGE_ACTION} != "unstage" ]]; then
    if command -v conda-stage > /dev/null; then
        >&2 echo "Auto staging conda environment '\${CONDA_DEFAULT_ENV}'. To disable, call 'conda-stage --auto-stage=disable'"
        conda-stage ${opts[*]}
    else
        >&2 echo "WARNING: Cannot auto stage conda environment '\${CONDA_DEFAULT_ENV}', because 'conda-stage' not found"
    fi
fi
EOF
        mv "${file}.tmp" "${file}"
        assert_file_exists "${file}"
        mdebug "${file}: $(echo; cat "${file}")"
        minfo "Enabled auto staging"
    else
        if [[ -f "${file}" ]]; then
            rm "${file}"
            [[ -f "${file}" ]] && merror "Failed to remove file: ${file}"
        fi
        minfo "Disabled auto staging"
    fi
    
    exit 0    
fi

if [[ "${action}" == "unstage" ]]; then
    minfo "Unstaging and reverting to original conda environment  ..."
    ## Assert that we are working with a staged environment
    if [[ -z ${CONDA_PREFIX} ]]; then
        merror "Does not look like a staged environment: CONDA_PREFIX is not set"
    fi
    assert_dir_exists "${CONDA_PREFIX}"

    if [[ ! -f "${CONDA_PREFIX}/.conda-stage" ]]; then
        merror "Does not look like a staged environment: No '${CONDA_PREFIX}/.conda-stage' file found"
    fi

    mdebug "- Staged conda environment: ${CONDA_PREFIX}"

    original=$(cat "${CONDA_PREFIX}/.conda-stage")
    minfo "Original conda environment: ${original}"

    t0=$SECONDS
    minfo "Removing all staged files: ${CONDA_PREFIX}"
    ## Atomic removal
    mv "${CONDA_PREFIX}" "${CONDA_PREFIX}.tmp"
    ## In case it's a read-only staged folder, unlock it
    chmod -R u+w "${CONDA_PREFIX}.tmp"
    rm -rf "${CONDA_PREFIX}.tmp"

    cmd="CONDA_STAGE_ACTION=unstage conda activate \"${original}\""
    mdebug "Command to activate original conda environment: $cmd"
    echo "$cmd"

    minfo "Activating original conda environment: ${original}"

    dt=$((SECONDS - t0))
    minfo "Total unstage time: ${dt} seconds"
    
    exit 0
fi

if [[ "${action}" == "stage" ]]; then
    minfo "Staging current conda environment (${CONDA_PREFIX}) to local disk ..."
    mdebug "- Using conda-stage $(version)"

    conda_env_name=${CONDA_DEFAULT_ENV}    
    conda_pack_cache_file=$(conda_pack)
    exit_code=$?
    if [[ $exit_code -ne 0 ]]; then
        exit "$exit_code"
    fi

    if [[ -z $path ]]; then
        path=$(mktemp --directory --tmpdir="${TMPDIR}" conda-stage-XXXX)
        path=${path}/${conda_env_name}
    fi
    if [[ -d "${path}" ]]; then
        merror "Stage folder must not exist: ${path}"
    fi
    mdebug "- Stage path: ${path}"

    minfo "Extracting $(file_info "${conda_pack_cache_file}") to ${path}"
    t0=$SECONDS
    ## Create stage folder so it's blocked while we extract
    make_dir "${path}"
    ## Extract atomically, i.e. write to temporary folder and rename
    make_dir "${path}.tmp"
    tar -xf "${conda_pack_cache_file}" -C "${path}.tmp"
    chmod -R u+w "${path}.tmp"
    remove_dir "${path}"
    mv "${path}.tmp" "${path}"
    dt=$((SECONDS - t0))
    minfo "Total extract time: ${dt} seconds"

    ## Record original conda environment
    echo "${CONDA_PREFIX}" > "${path}/.conda-stage"

    minfo "Unpacking"
    t0=$SECONDS
    # shellcheck source=/dev/null
    source "${path}/bin/activate"
    conda-unpack
    dt=$((SECONDS - t0))
    minfo "Total 'conda-unpack' time: ${dt} seconds"
    
    ## Set the conda prompt used by PS1 prompt (optional)
    conda config --env --set env_prompt "(${conda_env_name}*) "
    
    if $readonly; then
        minfo "Make staged environment read-only"
        chmod -R ugo-w "${path}"
    fi

    cmd="CONDA_STAGE_ACTION=stage conda activate \"${path}\""
    mdebug "Command to activate staged conda environment: $cmd"
    echo "$cmd"
    
    minfo "Activating staged conda environment: ${path}"
    exit 0
fi
